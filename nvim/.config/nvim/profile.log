SCRIPT  /Users/william/.local/share/nvim/lazy/typescript-tools.nvim/ftplugin/typescript.lua
Sourced 1 time
Total time:   0.001001
 Self time:   0.001001

count  total (s)   self (s)
                            require("typescript-tools.user_commands").setup_user_commands()

SCRIPT  /usr/local/share/nvim/runtime/ftplugin/typescript.vim
Sourced 1 time
Total time:   0.000376
 Self time:   0.000376

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	TypeScript
                            " Maintainer:	Doug Kearns <dougkearns@gmail.com>
                            " Last Change:	2024 Jan 14
                            " 		2024 May 23 by Riley Bruins <ribru17@gmail.com> ('commentstring')
                            
    1              0.000016 if exists("b:did_ftplugin")
                              finish
    1              0.000001 endif
    1              0.000006 let b:did_ftplugin = 1
                            
    1              0.000008 let s:cpo_save = &cpo
    1              0.000020 set cpo-=C
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    1              0.000009 setlocal formatoptions-=t formatoptions+=croql
                            
                            " Set 'comments' to format dashed lists in comments.
    1              0.000008 setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://
                            
    1              0.000004 setlocal commentstring=//\ %s
                            
    1              0.000005 setlocal suffixesadd+=.ts,.d.ts,.tsx,.js,.jsx,.cjs,.mjs
                            
    1              0.000003 let b:undo_ftplugin = "setl fo< com< cms< sua<"
                            
                            " Change the :browse e filter to primarily show TypeScript-related files.
    1              0.000010 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                                let  b:browsefilter="TypeScript Files (*.ts)\t*.ts\n" .
                            		\	"TypeScript Declaration Files (*.d.ts)\t*.d.ts\n" .
                            		\	"TSX Files (*.tsx)\t*.tsx\n" .
                            		\	"JavaScript Files (*.js)\t*.js\n" .
                            		\	"JavaScript Modules (*.es, *.cjs, *.mjs)\t*.es;*.cjs;*.mjs\n" .
                            		\	"JSON Files (*.json)\t*.json\n"
                                if has("win32")
                            	let b:browsefilter .= "All Files (*.*)\t*\n"
                                else
                            	let b:browsefilter .= "All Files (*)\t*\n"
                                endif
                                let b:undo_ftplugin .= " | unlet! b:browsefilter"
    1              0.000001 endif
                                   
    1              0.000007 let &cpo = s:cpo_save
    1              0.000005 unlet s:cpo_save

SCRIPT  /usr/local/share/nvim/runtime/indent/typescript.vim
Sourced 1 time
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
                            " Vim indent file
                            " Language: TypeScript
                            " Maintainer: See https://github.com/HerringtonDarkholme/yats.vim
                            " Last Change: 2019 Oct 18
                            "              2023 Aug 28 by Vim Project (undo_indent)
                            " Acknowledgement: Based off of vim-ruby maintained by Nikolai Weibull http://vim-ruby.rubyforge.org
                            
                            " 0. Initialization {{{1
                            " =================
                            
                            " Only load this indent file when no other was loaded.
    1              0.000008 if exists("b:did_indent")
                              finish
    1              0.000001 endif
    1              0.000004 let b:did_indent = 1
                            
    1              0.000009 setlocal nosmartindent
                            
                            " Now, set up our indentation expression and keys that trigger it.
    1              0.000007 setlocal indentexpr=GetTypescriptIndent()
    1              0.000004 setlocal formatexpr=Fixedgq(v:lnum,v:count)
    1              0.000005 setlocal indentkeys=0{,0},0),0],0\,,!^F,o,O,e
                            
    1              0.000003 let b:undo_indent = "setlocal formatexpr< indentexpr< indentkeys< smartindent<"
                            
                            " Only define the function once.
    1              0.000014 if exists("*GetTypescriptIndent")
    1              0.000002   finish
                            endif
                            
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            " 1. Variables {{{1
                            " ============
                            
                            let s:js_keywords = '^\s*\(break\|case\|catch\|continue\|debugger\|default\|delete\|do\|else\|finally\|for\|function\|if\|in\|instanceof\|new\|return\|switch\|this\|throw\|try\|typeof\|var\|void\|while\|with\)'
                            
                            " Regex of syntax group names that are or delimit string or are comments.
                            let s:syng_strcom = 'string\|regex\|comment\c'
                            
                            " Regex of syntax group names that are strings.
                            let s:syng_string = 'regex\c'
                            
                            " Regex of syntax group names that are strings or documentation.
                            let s:syng_multiline = 'comment\c'
                            
                            " Regex of syntax group names that are line comment.
                            let s:syng_linecom = 'linecomment\c'
                            
                            " Expression used to check whether we should skip a match with searchpair().
                            let s:skip_expr = "synIDattr(synID(line('.'),col('.'),1),'name') =~ '".s:syng_strcom."'"
                            
                            let s:line_term = '\s*\%(\%(\/\/\).*\)\=$'
                            
                            " Regex that defines continuation lines, not including (, {, or [.
                            let s:continuation_regex = '\%([\\*+/.:]\|\%(<%\)\@<![=-]\|\W[|&?]\|||\|&&\|[^=]=[^=].*,\)' . s:line_term
                            
                            " Regex that defines continuation lines.
                            " TODO: this needs to deal with if ...: and so on
                            let s:msl_regex = s:continuation_regex
                            
                            let s:one_line_scope_regex = '\<\%(if\|else\|for\|while\)\>[^{;]*' . s:line_term
                            
                            " Regex that defines blocks.
                            let s:block_regex = '\%([{[]\)\s*\%(|\%([*@]\=\h\w*,\=\s*\)\%(,\s*[*@]\=\h\w*\)*|\)\=' . s:line_term
                            
                            let s:var_stmt = '^\s*var'
                            
                            let s:comma_first = '^\s*,'
                            let s:comma_last = ',\s*$'
                            
                            let s:ternary = '^\s\+[?|:]'
                            let s:ternary_q = '^\s\+?'
                            
                            " 2. Auxiliary Functions {{{1
                            " ======================
                            
                            " Check if the character at lnum:col is inside a string, comment, or is ascii.
                            function s:IsInStringOrComment(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_strcom
                            endfunction
                            
                            " Check if the character at lnum:col is inside a string.
                            function s:IsInString(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_string
                            endfunction
                            
                            " Check if the character at lnum:col is inside a multi-line comment.
                            function s:IsInMultilineComment(lnum, col)
                              return !s:IsLineComment(a:lnum, a:col) && synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_multiline
                            endfunction
                            
                            " Check if the character at lnum:col is a line comment.
                            function s:IsLineComment(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name') =~ s:syng_linecom
                            endfunction
                            
                            " Find line above 'lnum' that isn't empty, in a comment, or in a string.
                            function s:PrevNonBlankNonString(lnum)
                              let in_block = 0
                              let lnum = prevnonblank(a:lnum)
                              while lnum > 0
                                " Go in and out of blocks comments as necessary.
                                " If the line isn't empty (with opt. comment) or in a string, end search.
                                let line = getline(lnum)
                                if line =~ '/\*'
                                  if in_block
                                    let in_block = 0
                                  else
                                    break
                                  endif
                                elseif !in_block && line =~ '\*/'
                                  let in_block = 1
                                elseif !in_block && line !~ '^\s*\%(//\).*$' && !(s:IsInStringOrComment(lnum, 1) && s:IsInStringOrComment(lnum, strlen(line)))
                                  break
                                endif
                                let lnum = prevnonblank(lnum - 1)
                              endwhile
                              return lnum
                            endfunction
                            
                            " Find line above 'lnum' that started the continuation 'lnum' may be part of.
                            function s:GetMSL(lnum, in_one_line_scope)
                              " Start on the line we're at and use its indent.
                              let msl = a:lnum
                              let lnum = s:PrevNonBlankNonString(a:lnum - 1)
                              while lnum > 0
                                " If we have a continuation line, or we're in a string, use line as MSL.
                                " Otherwise, terminate search as we have found our MSL already.
                                let line = getline(lnum)
                                let col = match(line, s:msl_regex) + 1
                                if (col > 0 && !s:IsInStringOrComment(lnum, col)) || s:IsInString(lnum, strlen(line))
                                  let msl = lnum
                                else
                                  " Don't use lines that are part of a one line scope as msl unless the
                                  " flag in_one_line_scope is set to 1
                                  "
                                  if a:in_one_line_scope
                                    break
                                  end
                                  let msl_one_line = s:Match(lnum, s:one_line_scope_regex)
                                  if msl_one_line == 0
                                    break
                                  endif
                                endif
                                let lnum = s:PrevNonBlankNonString(lnum - 1)
                              endwhile
                              return msl
                            endfunction
                            
                            function s:RemoveTrailingComments(content)
                              let single = '\/\/\(.*\)\s*$'
                              let multi = '\/\*\(.*\)\*\/\s*$'
                              return substitute(substitute(a:content, single, '', ''), multi, '', '')
                            endfunction
                            
                            " Find if the string is inside var statement (but not the first string)
                            function s:InMultiVarStatement(lnum)
                              let lnum = s:PrevNonBlankNonString(a:lnum - 1)
                            
                            "  let type = synIDattr(synID(lnum, indent(lnum) + 1, 0), 'name')
                            
                              " loop through previous expressions to find a var statement
                              while lnum > 0
                                let line = getline(lnum)
                            
                                " if the line is a js keyword
                                if (line =~ s:js_keywords)
                                  " check if the line is a var stmt
                                  " if the line has a comma first or comma last then we can assume that we
                                  " are in a multiple var statement
                                  if (line =~ s:var_stmt)
                                    return lnum
                                  endif
                            
                                  " other js keywords, not a var
                                  return 0
                                endif
                            
                                let lnum = s:PrevNonBlankNonString(lnum - 1)
                              endwhile
                            
                              " beginning of program, not a var
                              return 0
                            endfunction
                            
                            " Find line above with beginning of the var statement or returns 0 if it's not
                            " this statement
                            function s:GetVarIndent(lnum)
                              let lvar = s:InMultiVarStatement(a:lnum)
                              let prev_lnum = s:PrevNonBlankNonString(a:lnum - 1)
                            
                              if lvar
                                let line = s:RemoveTrailingComments(getline(prev_lnum))
                            
                                " if the previous line doesn't end in a comma, return to regular indent
                                if (line !~ s:comma_last)
                                  return indent(prev_lnum) - shiftwidth()
                                else
                                  return indent(lvar) + shiftwidth()
                                endif
                              endif
                            
                              return -1
                            endfunction
                            
                            
                            " Check if line 'lnum' has more opening brackets than closing ones.
                            function s:LineHasOpeningBrackets(lnum)
                              let open_0 = 0
                              let open_2 = 0
                              let open_4 = 0
                              let line = getline(a:lnum)
                              let pos = match(line, '[][(){}]', 0)
                              while pos != -1
                                if !s:IsInStringOrComment(a:lnum, pos + 1)
                                  let idx = stridx('(){}[]', line[pos])
                                  if idx % 2 == 0
                                    let open_{idx} = open_{idx} + 1
                                  else
                                    let open_{idx - 1} = open_{idx - 1} - 1
                                  endif
                                endif
                                let pos = match(line, '[][(){}]', pos + 1)
                              endwhile
                              return (open_0 > 0) . (open_2 > 0) . (open_4 > 0)
                            endfunction
                            
                            function s:Match(lnum, regex)
                              let col = match(getline(a:lnum), a:regex) + 1
                              return col > 0 && !s:IsInStringOrComment(a:lnum, col) ? col : 0
                            endfunction
                            
                            function s:IndentWithContinuation(lnum, ind, width)
                              " Set up variables to use and search for MSL to the previous line.
                              let p_lnum = a:lnum
                              let lnum = s:GetMSL(a:lnum, 1)
                              let line = getline(lnum)
                            
                              " If the previous line wasn't a MSL and is continuation return its indent.
                              " TODO: the || s:IsInString() thing worries me a bit.
                              if p_lnum != lnum
                                if s:Match(p_lnum,s:continuation_regex)||s:IsInString(p_lnum,strlen(line))
                                  return a:ind
                                endif
                              endif
                            
                              " Set up more variables now that we know we aren't continuation bound.
                              let msl_ind = indent(lnum)
                            
                              " If the previous line ended with [*+/.-=], start a continuation that
                              " indents an extra level.
                              if s:Match(lnum, s:continuation_regex)
                                if lnum == p_lnum
                                  return msl_ind + a:width
                                else
                                  return msl_ind
                                endif
                              endif
                            
                              return a:ind
                            endfunction
                            
                            function s:InOneLineScope(lnum)
                              let msl = s:GetMSL(a:lnum, 1)
                              if msl > 0 && s:Match(msl, s:one_line_scope_regex)
                                return msl
                              endif
                              return 0
                            endfunction
                            
                            function s:ExitingOneLineScope(lnum)
                              let msl = s:GetMSL(a:lnum, 1)
                              if msl > 0
                                " if the current line is in a one line scope ..
                                if s:Match(msl, s:one_line_scope_regex)
                                  return 0
                                else
                                  let prev_msl = s:GetMSL(msl - 1, 1)
                                  if s:Match(prev_msl, s:one_line_scope_regex)
                                    return prev_msl
                                  endif
                                endif
                              endif
                              return 0
                            endfunction
                            
                            " 3. GetTypescriptIndent Function {{{1
                            " =========================
                            
                            function GetTypescriptIndent()
                              " 3.1. Setup {{{2
                              " ----------
                            
                              " Set up variables for restoring position in file.  Could use v:lnum here.
                              let vcol = col('.')
                            
                              " 3.2. Work on the current line {{{2
                              " -----------------------------
                            
                              let ind = -1
                              " Get the current line.
                              let line = getline(v:lnum)
                              " previous nonblank line number
                              let prevline = prevnonblank(v:lnum - 1)
                            
                              " If we got a closing bracket on an empty line, find its match and indent
                              " according to it.  For parentheses we indent to its column - 1, for the
                              " others we indent to the containing line's MSL's level.  Return -1 if fail.
                              let col = matchend(line, '^\s*[],})]')
                              if col > 0 && !s:IsInStringOrComment(v:lnum, col)
                                call cursor(v:lnum, col)
                            
                                let lvar = s:InMultiVarStatement(v:lnum)
                                if lvar
                                  let prevline_contents = s:RemoveTrailingComments(getline(prevline))
                            
                                  " check for comma first
                                  if (line[col - 1] =~ ',')
                                    " if the previous line ends in comma or semicolon don't indent
                                    if (prevline_contents =~ '[;,]\s*$')
                                      return indent(s:GetMSL(line('.'), 0))
                                    " get previous line indent, if it's comma first return prevline indent
                                    elseif (prevline_contents =~ s:comma_first)
                                      return indent(prevline)
                                    " otherwise we indent 1 level
                                    else
                                      return indent(lvar) + shiftwidth()
                                    endif
                                  endif
                                endif
                            
                            
                                let bs = strpart('(){}[]', stridx(')}]', line[col - 1]) * 2, 2)
                                if searchpair(escape(bs[0], '\['), '', bs[1], 'bW', s:skip_expr) > 0
                                  if line[col-1]==')' && col('.') != col('$') - 1
                                    let ind = virtcol('.')-1
                                  else
                                    let ind = indent(s:GetMSL(line('.'), 0))
                                  endif
                                endif
                                return ind
                              endif
                            
                              " If the line is comma first, dedent 1 level
                              if (getline(prevline) =~ s:comma_first)
                                return indent(prevline) - shiftwidth()
                              endif
                            
                              if (line =~ s:ternary)
                                if (getline(prevline) =~ s:ternary_q)
                                  return indent(prevline)
                                else
                                  return indent(prevline) + shiftwidth()
                                endif
                              endif
                            
                              " If we are in a multi-line comment, cindent does the right thing.
                              if s:IsInMultilineComment(v:lnum, 1) && !s:IsLineComment(v:lnum, 1)
                                return cindent(v:lnum)
                              endif
                            
                              " Check for multiple var assignments
                            "  let var_indent = s:GetVarIndent(v:lnum)
                            "  if var_indent >= 0
                            "    return var_indent
                            "  endif
                            
                              " 3.3. Work on the previous line. {{{2
                              " -------------------------------
                            
                              " If the line is empty and the previous nonblank line was a multi-line
                              " comment, use that comment's indent. Deduct one char to account for the
                              " space in ' */'.
                              if line =~ '^\s*$' && s:IsInMultilineComment(prevline, 1)
                                return indent(prevline) - 1
                              endif
                            
                              " Find a non-blank, non-multi-line string line above the current line.
                              let lnum = s:PrevNonBlankNonString(v:lnum - 1)
                            
                              " If the line is empty and inside a string, use the previous line.
                              if line =~ '^\s*$' && lnum != prevline
                                return indent(prevnonblank(v:lnum))
                              endif
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                            
                              " Set up variables for current line.
                              let line = getline(lnum)
                              let ind = indent(lnum)
                            
                              " If the previous line ended with a block opening, add a level of indent.
                              if s:Match(lnum, s:block_regex)
                                return indent(s:GetMSL(lnum, 0)) + shiftwidth()
                              endif
                            
                              " If the previous line contained an opening bracket, and we are still in it,
                              " add indent depending on the bracket type.
                              if line =~ '[[({]'
                                let counts = s:LineHasOpeningBrackets(lnum)
                                if counts[0] == '1' && searchpair('(', '', ')', 'bW', s:skip_expr) > 0
                                  if col('.') + 1 == col('$')
                                    return ind + shiftwidth()
                                  else
                                    return virtcol('.')
                                  endif
                                elseif counts[1] == '1' || counts[2] == '1'
                                  return ind + shiftwidth()
                                else
                                  call cursor(v:lnum, vcol)
                                end
                              endif
                            
                              " 3.4. Work on the MSL line. {{{2
                              " --------------------------
                            
                              let ind_con = ind
                              let ind = s:IndentWithContinuation(lnum, ind_con, shiftwidth())
                            
                              " }}}2
                              "
                              "
                              let ols = s:InOneLineScope(lnum)
                              if ols > 0
                                let ind = ind + shiftwidth()
                              else
                                let ols = s:ExitingOneLineScope(lnum)
                                while ols > 0 && ind > 0
                                  let ind = ind - shiftwidth()
                                  let ols = s:InOneLineScope(ols - 1)
                                endwhile
                              endif
                            
                              return ind
                            endfunction
                            
                            " }}}1
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            
                            function! Fixedgq(lnum, count)
                                let l:tw = &tw ? &tw : 80
                            
                                let l:count = a:count
                                let l:first_char = indent(a:lnum) + 1
                            
                                if mode() == 'i' " gq was not pressed, but tw was set
                                    return 1
                                endif
                            
                                " This gq is only meant to do code with strings, not comments
                                if s:IsLineComment(a:lnum, l:first_char) || s:IsInMultilineComment(a:lnum, l:first_char)
                                    return 1
                                endif
                            
                                if len(getline(a:lnum)) < l:tw && l:count == 1 " No need for gq
                                    return 1
                                endif
                            
                                " Put all the lines on one line and do normal splitting after that
                                if l:count > 1
                                    while l:count > 1
                                        let l:count -= 1
                                        normal J
                                    endwhile
                                endif
                            
                                let l:winview = winsaveview()
                            
                                call cursor(a:lnum, l:tw + 1)
                                let orig_breakpoint = searchpairpos(' ', '', '\.', 'bcW', '', a:lnum)
                                call cursor(a:lnum, l:tw + 1)
                                let breakpoint = searchpairpos(' ', '', '\.', 'bcW', s:skip_expr, a:lnum)
                            
                                " No need for special treatment, normal gq handles edgecases better
                                if breakpoint[1] == orig_breakpoint[1]
                                    call winrestview(l:winview)
                                    return 1
                                endif
                            
                                " Try breaking after string
                                if breakpoint[1] <= indent(a:lnum)
                                    call cursor(a:lnum, l:tw + 1)
                                    let breakpoint = searchpairpos('\.', '', ' ', 'cW', s:skip_expr, a:lnum)
                                endif
                            
                            
                                if breakpoint[1] != 0
                                    call feedkeys("r\<CR>")
                                else
                                    let l:count = l:count - 1
                                endif
                            
                                " run gq on new lines
                                if l:count == 1
                                    call feedkeys("gqq")
                                endif
                            
                                return 0
                            endfunction

SCRIPT  /Users/william/.local/share/nvim/lazy/oil.nvim/syntax/oil.vim
Sourced 8 times
Total time:   0.008105
 Self time:   0.008105

count  total (s)   self (s)
    8              0.000296 if exists("b:current_syntax")
                              finish
    8              0.000008 endif
                            
    8              0.005276 syn match oilId /^\/\d* / conceal
                            
    8              0.000050 let b:current_syntax = "oil"

FUNCTION  <SNR>51_inputtarget()
    Defined: ~/.local/share/nvim/lazy/vim-surround/plugin/surround.vim:21
Called 2 times
Total time:   0.119892
 Self time:   0.000412

count  total (s)   self (s)
    2   0.119536   0.000056   let c = s:getchar()
    2              0.000068   while c =~ '^\d\+$'
                                let c .= s:getchar()
    2              0.000004   endwhile
    2              0.000007   if c == " "
                                let c .= s:getchar()
    2              0.000002   endif
    2              0.000051   if c =~ "\<Esc>\|\<C-C>\|\0"
                                return ""
    2              0.000002   else
    2              0.000002     return c
                              endif

FUNCTION  <SNR>51_inputreplacement()
    Defined: ~/.local/share/nvim/lazy/vim-surround/plugin/surround.vim:36
Called 1 time
Total time:   0.061341
 Self time:   0.000069

count  total (s)   self (s)
    1   0.061312   0.000040   let c = s:getchar()
    1              0.000006   if c == " "
                                let c .= s:getchar()
    1              0.000001   endif
    1              0.000012   if c =~ "\<Esc>" || c =~ "\<C-C>"
    1              0.000002     return ""
                              else
                                return c
                              endif

FUNCTION  CursorHold_Cb()
    Defined: ~/.local/share/nvim/lazy/FixCursorHold.nvim/plugin/fix_cursorhold_nvim.vim:19
Called 7 times
Total time:   0.002739
 Self time:   0.001368

count  total (s)   self (s)
    7              0.000225   if v:exiting isnot v:null
                                return
    7              0.000015   endif
    7   0.001483   0.000424   set eventignore-=CursorHold
    7   0.000429   0.000155   doautocmd <nomodeline> CursorHold
    7   0.000129   0.000091   set eventignore+=CursorHold

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /usr/local/share/nvim/runtime/ftplugin.vim:15
Called 24 times
Total time:   0.271797
 Self time:   0.270372

count  total (s)   self (s)
   24              0.001258     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
   24              0.000027     endif
                            
   24              0.000164     let s = expand("<amatch>")
   24              0.000071     if s != ""
   24              0.000267       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
   24              0.000018       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   48              0.000392       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
   24   0.268427   0.267001         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
   48              0.000176       endfor
   24              0.000027     endif

FUNCTION  <SNR>51_beep()
    Defined: ~/.local/share/nvim/lazy/vim-surround/plugin/surround.vim:48
Called 1 time
Total time:   0.000128
 Self time:   0.000128

count  total (s)   self (s)
    1              0.000122   exe "norm! \<Esc>"
    1              0.000005   return ""

FUNCTION  <SNR>2_LoadIndent()
    Defined: /usr/local/share/nvim/runtime/indent.vim:14
Called 24 times
Total time:   0.044325
 Self time:   0.044236

count  total (s)   self (s)
   24              0.000290     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
   24              0.000020     endif
   24              0.000148     let s = expand("<amatch>")
   24              0.000060     if s != ""
   24              0.000091       if exists("b:did_indent")
                            	unlet b:did_indent
   24              0.000021       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   48              0.000390       for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
   24   0.041416   0.041327         exe $'runtime! indent/{name}[.]{{vim,lua}}'
   48              0.000314       endfor
   24              0.000022     endif

FUNCTION  <SNR>26_Highlight_Matching_Pair()
    Defined: /usr/local/share/nvim/runtime/plugin/matchparen.vim:47
Called 333 times
Total time:   0.112751
 Self time:   0.099490

count  total (s)   self (s)
  333              0.005881   if !exists("w:matchparen_ids")
    6              0.000030     let w:matchparen_ids = []
  333              0.000636   endif
                              " Remove any previous match.
  333   0.027166   0.013905   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  333              0.004000   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
    2              0.000006     return
  331              0.000299   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  331              0.002888   let c_lnum = line('.')
  331              0.001571   let c_col = col('.')
  331              0.000792   let before = 0
                            
  331              0.001883   let text = getline(c_lnum)
  331              0.003743   let c_before = text->strpart(0, c_col - 1)->slice(-1)
  331              0.003423   let c = text->strpart(c_col - 1)->slice(0, 1)
  331              0.015685   let plist = split(&matchpairs, '.\zs[:,]')
  331              0.002977   let i = index(plist, c)
  331              0.000810   if i < 0
                                " not found, in Insert mode try character before the cursor
  299              0.002508     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   58              0.000194       let before = strlen(c_before)
   58              0.000102       let c = c_before
   58              0.000176       let i = index(plist, c)
  299              0.000316     endif
  299              0.000703     if i < 0
                                  " not found, nothing to do
  299              0.000756       return
                                endif
   32              0.000024   endif
                            
                              " Figure out the arguments for searchpairpos().
   32              0.000082   if i % 2 == 0
   12              0.000026     let s_flags = 'nW'
   12              0.000099     let c2 = plist[i + 1]
   20              0.000030   else
   20              0.000048     let s_flags = 'nbW'
   20              0.000047     let c2 = c
   20              0.000101     let c = plist[i - 1]
   32              0.000029   endif
   32              0.000091   if c == '['
    7              0.000011     let c = '\['
    7              0.000009     let c2 = '\]'
   32              0.000024   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   32              0.000116   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
   32              0.000025   endif
                            
   32              0.000361   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
   32              0.000029   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
   32              0.000265     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
   32              0.000058     try
   32              0.003400       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
   32              0.000064     endtry
   32              0.000026   endif
                            
                              " Limit the search to lines visible in the window.
   32              0.000183   let stoplinebottom = line('w$')
   32              0.000121   let stoplinetop = line('w0')
   32              0.000071   if i % 2 == 0
   12              0.000034     let stopline = stoplinebottom
   20              0.000017   else
   20              0.000063     let stopline = stoplinetop
   32              0.000025   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   32              0.000157   if mode() == 'i' || mode() == 'R'
    1              0.000006     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
   31              0.000024   else
   31              0.000492     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   32              0.000030   endif
   32              0.000031   try
   32              0.008712     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
   32              0.000046   endtry
                            
   32              0.000070   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
   32              0.000025   endif
                            
                              " If a match is found setup match highlighting.
   32              0.000177   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   26              0.000066     if s:has_matchaddpos
   26              0.000084       if !g:matchparen_disable_cursor_hl
   26              0.000641         call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                  else
                                    call add(w:matchparen_ids, matchaddpos('MatchParen', [[m_lnum, m_col]], 10))
   26              0.000024       endif
                                else
                                  if !g:matchparen_disable_cursor_hl
                                    exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                  else
                                    exe '3match MatchParen /\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                  endif
                                  call add(w:matchparen_ids, 3)
   26              0.000022     endif
   26              0.000088     let w:paren_hl_on = 1
   32              0.000027   endif

FUNCTION  CursorHoldITimer()
    Defined: ~/.local/share/nvim/lazy/FixCursorHold.nvim/plugin/fix_cursorhold_nvim.vim:44
Called 30 times
Total time:   0.002428
 Self time:   0.002428

count  total (s)   self (s)
   30              0.001919   call timer_stop(g:fix_cursorhold_nvim_timer)
   30              0.000455   let g:fix_cursorhold_nvim_timer = timer_start(g:cursorhold_updatetime, 'CursorHoldI_Cb')

FUNCTION  <SNR>42_SynSet()
    Defined: /usr/local/share/nvim/runtime/syntax/synload.vim:27
Called 26 times
Total time:   0.190761
 Self time:   0.182614

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
   26              0.000171   syn clear
   26              0.000129   if exists("b:current_syntax")
                                unlet b:current_syntax
   26              0.000036   endif
                            
   26              0.000231   0verbose let s = expand("<amatch>")
   26              0.000062   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
   26              0.000046   elseif s == "OFF"
                                let s = ""
   26              0.000014   endif
                            
   26              0.000040   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
   50              0.000246     for name in split(s, '\.')
   25              0.000059       if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
   25   0.188779   0.180632         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
   25              0.000074       endif
   50              0.000113     endfor
   26              0.000019   endif

FUNCTION  <SNR>51_getchar()
    Defined: ~/.local/share/nvim/lazy/vim-surround/plugin/surround.vim:13
Called 3 times
Total time:   0.180752
 Self time:   0.133467

count  total (s)   self (s)
    3   0.179651   0.132366   let c = getchar()
    3              0.000773   if c =~ '^\d\+$'
    3              0.000271     let c = nr2char(c)
    3              0.000008   endif
    3              0.000009   return c

FUNCTION  nvim_treesitter#indent()
    Defined: ~/.local/share/nvim/lazy/nvim-treesitter/autoload/nvim_treesitter.vim:25
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            	return luaeval(printf('require"nvim-treesitter.indent".get_indent(%d)', v:lnum))

FUNCTION  <SNR>26_Remove_Matches()
    Defined: /usr/local/share/nvim/runtime/plugin/matchparen.vim:213
Called 375 times
Total time:   0.014936
 Self time:   0.014936

count  total (s)   self (s)
  375              0.003213   if exists('w:paren_hl_on') && w:paren_hl_on
   52              0.000556     while !empty(w:matchparen_ids)
   26              0.000397       silent! call remove(w:matchparen_ids, 0)->matchdelete()
   52              0.000091     endwhile
   26              0.000136     let w:paren_hl_on = 0
  375              0.000382   endif

FUNCTION  undotree#UndotreePersistUndo()
    Defined: ~/.local/share/nvim/lazy/undotree/autoload/undotree.vim:1472
Called 3 times
Total time:   0.006848
 Self time:   0.006766

count  total (s)   self (s)
    3   0.000471   0.000417     call s:log("undotree#UndotreePersistUndo(" . a:goSetUndofile . ")")
    3              0.000012     if ! &undofile
    3              0.000054         if !isdirectory(g:undotree_UndoDir)
                                        call mkdir(g:undotree_UndoDir, 'p', 0700)
                                        call s:log(" > [Dir " . g:undotree_UndoDir . "] created.")
    3              0.000002         endif
    3              0.000055         exe "set undodir=" . fnameescape(g:undotree_UndoDir)
    3   0.000065   0.000037         call s:log(" > [set undodir=" . g:undotree_UndoDir . "] executed.")
    3              0.004783         if filereadable(undofile(expand('%'))) || a:goSetUndofile
                                        setlocal undofile
                                        call s:log(" > [setlocal undofile] executed")
    3              0.000003         endif
    3              0.000005         if a:goSetUndofile
                                        silent! write
                                        echo "A persistence undo file has been created."
    3              0.000002         endif
                                else
                                    call s:log(" > Undofile has been set. Do nothing.")
    3              0.000002     endif

FUNCTION  <SNR>51_changesurround()
    Defined: ~/.local/share/nvim/lazy/vim-surround/plugin/surround.vim:494
Called 1 time
Total time:   0.135037
 Self time:   0.000263

count  total (s)   self (s)
    1   0.073408   0.000103   let a = s:inputtarget()
    1              0.000003   if a == ""
                                return s:beep()
    1              0.000001   endif
    1   0.061474   0.000132   let b = s:inputreplacement()
    1              0.000001   if b == ""
    1   0.000141   0.000013     return s:beep()
                              endif
                              call s:dosurround(a,b,a:0 && a:1)

FUNCTION  <SNR>13_dopopd()
    Defined: ~/.local/share/nvim/lazy/fzf/plugin/fzf.vim:631
Called 19 times
Total time:   0.000297
 Self time:   0.000297

count  total (s)   self (s)
   19              0.000145   if !exists('w:fzf_pushd')
   19              0.000060     return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet! w:fzf_pushd

FUNCTION  CursorHoldTimer()
    Defined: ~/.local/share/nvim/lazy/FixCursorHold.nvim/plugin/fix_cursorhold_nvim.vim:37
Called 202 times
Total time:   0.013272
 Self time:   0.013272

count  total (s)   self (s)
  202              0.003123   call timer_stop(g:fix_cursorhold_nvim_timer)
  202              0.000824   if mode() == 'n'
  196              0.007496     let g:fix_cursorhold_nvim_timer = timer_start(g:cursorhold_updatetime, 'CursorHold_Cb')
  202              0.000326   endif

FUNCTION  <SNR>51_dosurround()
    Defined: ~/.local/share/nvim/lazy/vim-surround/plugin/surround.vim:369
Called 1 time
Total time:   0.003239
 Self time:   0.002726

count  total (s)   self (s)
    1              0.000007   let sol_save = &startofline
    1   0.000035   0.000011   set startofline
    1              0.000002   let scount = v:count1
    1              0.000003   let char = (a:0 ? a:1 : s:inputtarget())
    1              0.000001   let spc = ""
    1              0.000003   if char =~ '^\d\+'
                                let scount = scount * matchstr(char,'^\d\+')
                                let char = substitute(char,'^\d\+','','')
    1              0.000000   endif
    1              0.000002   if char =~ '^ '
                                let char = strpart(char,1)
                                let spc = 1
    1              0.000000   endif
    1              0.000001   if char == 'a'
                                let char = '>'
    1              0.000000   endif
    1              0.000001   if char == 'r'
                                let char = ']'
    1              0.000000   endif
    1              0.000001   let newchar = ""
    1              0.000001   if a:0 > 1
                                let newchar = a:2
                                if newchar == "\<Esc>" || newchar == "\<C-C>" || newchar == ""
                                  if !sol_save
                                    set nostartofline
                                  endif
                                  return s:beep()
                                endif
    1              0.000000   endif
    1              0.000002   let cb_save = &clipboard
    1   0.000021   0.000013   set clipboard-=unnamed clipboard-=unnamedplus
    1              0.000002   let append = ""
    1              0.001994   let original = getreg('"')
    1              0.000097   let otype = getregtype('"')
    1              0.000364   call setreg('"',"")
    1              0.000010   let strcount = (scount == 1 ? "" : scount)
    1              0.000003   if char == '/'
                                exe 'norm! '.strcount.'[/d'.strcount.']/'
    1              0.000013   elseif char =~# '[[:punct:][:space:]]' && char !~# '[][(){}<>"''`]'
                                exe 'norm! T'.char
                                if getline('.')[col('.')-1] == char
                                  exe 'norm! l'
                                endif
                                exe 'norm! dt'.char
    1              0.000000   else
    1   0.000579   0.000108     exe 'norm! d'.strcount.'i'.char
    1              0.000001   endif
    1              0.000005   let keeper = getreg('"')
    1              0.000001   let okeeper = keeper " for reindent below
    1              0.000002   if keeper == ""
    1              0.000016     call setreg('"',original,otype)
    1   0.000017   0.000010     let &clipboard = cb_save
    1              0.000001     if !sol_save
    1   0.000009   0.000005       set nostartofline
    1              0.000001     endif
    1              0.000002     return ""
                              endif
                              let oldline = getline('.')
                              let oldlnum = line('.')
                              if char ==# "p"
                                call setreg('"','','V')
                              elseif char ==# "s" || char ==# "w" || char ==# "W"
                                " Do nothing
                                call setreg('"','')
                              elseif char =~ "[\"'`]"
                                exe "norm! i \<Esc>d2i".char
                                call setreg('"',substitute(getreg('"'),' ','',''))
                              elseif char == '/'
                                norm! "_x
                                call setreg('"','/**/',"c")
                                let keeper = substitute(substitute(keeper,'^/\*\s\=','',''),'\s\=\*$','','')
                              elseif char =~# '[[:punct:][:space:]]' && char !~# '[][(){}<>]'
                                exe 'norm! F'.char
                                exe 'norm! df'.char
                              else
                                " One character backwards
                                call search('\m.', 'bW')
                                exe "norm! da".char
                              endif
                              let removed = getreg('"')
                              let rem2 = substitute(removed,'\n.*','','')
                              let oldhead = strpart(oldline,0,strlen(oldline)-strlen(rem2))
                              let oldtail = strpart(oldline,  strlen(oldline)-strlen(rem2))
                              let regtype = getregtype('"')
                              if char =~# '[\[({<T]' || spc
                                let keeper = substitute(keeper,'^\s\+','','')
                                let keeper = substitute(keeper,'\s\+$','','')
                              endif
                              if col("']") == col("$") && virtcol('.') + 1 == virtcol('$')
                                if oldhead =~# '^\s*$' && a:0 < 2
                                  let keeper = substitute(keeper,'\%^\n'.oldhead.'\(\s*.\{-\}\)\n\s*\%$','\1','')
                                endif
                                let pcmd = "p"
                              else
                                let pcmd = "P"
                              endif
                              if line('.') + 1 < oldlnum && regtype ==# "V"
                                let pcmd = "p"
                              endif
                              call setreg('"',keeper,regtype)
                              if newchar != ""
                                let special = a:0 > 2 ? a:3 : 0
                                call s:wrapreg('"',newchar,removed,special)
                              endif
                              silent exe 'norm! ""'.pcmd.'`['
                              if removed =~ '\n' || okeeper =~ '\n' || getreg('"') =~ '\n'
                                call s:reindent()
                              endif
                              if getline('.') =~ '^\s\+$' && keeper =~ '^\s*\n'
                                silent norm! cc
                              endif
                              call setreg('"',original,otype)
                              let s:lastdel = removed
                              let &clipboard = cb_save
                              if newchar == ""
                                silent! call repeat#set("\<Plug>Dsurround".char,scount)
                              else
                                silent! call repeat#set("\<Plug>C".(a:0 > 2 && a:3 ? "S" : "s")."urround".char.newchar.s:input,scount)
                              endif
                              if !sol_save
                                set nostartofline
                              endif

FUNCTION  <SNR>60_log()
    Defined: ~/.local/share/nvim/lazy/undotree/autoload/undotree.vim:201
Called 6 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    6              0.000016     if s:debug
                                    exec 'redir >> ' . s:debugfile
                                    silent echon strftime('%H:%M:%S') . ': ' . string(a:msg) . "\n"
                                    redir END
    6              0.000005     endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   24   0.271797   0.270372  <SNR>1_LoadFTPlugin()
   26   0.190761   0.182614  <SNR>42_SynSet()
    3   0.180752   0.133467  <SNR>51_getchar()
    1   0.135037   0.000263  <SNR>51_changesurround()
    2   0.119892   0.000412  <SNR>51_inputtarget()
  333   0.112751   0.099490  <SNR>26_Highlight_Matching_Pair()
    1   0.061341   0.000069  <SNR>51_inputreplacement()
   24   0.044325   0.044236  <SNR>2_LoadIndent()
  375   0.014936             <SNR>26_Remove_Matches()
  202   0.013272             CursorHoldTimer()
    3   0.006848   0.006766  undotree#UndotreePersistUndo()
    1   0.003239   0.002726  <SNR>51_dosurround()
    7   0.002739   0.001368  CursorHold_Cb()
   30   0.002428             CursorHoldITimer()
   19   0.000297             <SNR>13_dopopd()
    1   0.000128             <SNR>51_beep()
    6   0.000082             <SNR>60_log()
                             nvim_treesitter#indent()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   24   0.271797   0.270372  <SNR>1_LoadFTPlugin()
   26   0.190761   0.182614  <SNR>42_SynSet()
    3   0.180752   0.133467  <SNR>51_getchar()
  333   0.112751   0.099490  <SNR>26_Highlight_Matching_Pair()
   24   0.044325   0.044236  <SNR>2_LoadIndent()
  375              0.014936  <SNR>26_Remove_Matches()
  202              0.013272  CursorHoldTimer()
    3   0.006848   0.006766  undotree#UndotreePersistUndo()
    1   0.003239   0.002726  <SNR>51_dosurround()
   30              0.002428  CursorHoldITimer()
    7   0.002739   0.001368  CursorHold_Cb()
    2   0.119892   0.000412  <SNR>51_inputtarget()
   19              0.000297  <SNR>13_dopopd()
    1   0.135037   0.000263  <SNR>51_changesurround()
    1              0.000128  <SNR>51_beep()
    6              0.000082  <SNR>60_log()
    1   0.061341   0.000069  <SNR>51_inputreplacement()
                             nvim_treesitter#indent()

